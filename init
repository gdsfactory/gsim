#!/usr/bin/env -S uv run --script

import argparse
import fnmatch
import os
import re
import shutil
import subprocess
from pathlib import Path
from typing import Pattern


def parse_args():
    parser = argparse.ArgumentParser(description="Initialize repository")

    parser.add_argument(
        "name",
        nargs="?",
        default="dotemplate",
        type=str,
        help="Path to initialize repository (default: dotemplate)",
    )

    parser.add_argument(
        "--capitalized-name",
        "-N",
        default="",
        help="Capitalized name of the repository (default: empty)",
    )

    parser.add_argument(
        "--description",
        "-d",
        default="",
        help="Author of the repository (default: empty)",
    )

    parser.add_argument(
        "--github-organization",
        "-o",
        default="doplaydo",
        help="GitHub organization for this repository (default: doplaydo)",
    )

    parser.add_argument(
        "--no-delete-init",
        "-D",
        action="store_false",
        dest="delete_init",
        help="Do not delete init script after initializing (default: do not delete)",
    )

    parser.add_argument(
        "--version", "-v", default="0.0.0", help="Initial version (default: 0.0.0)"
    )

    parser.add_argument(
        "--initial-commit",
        "-c",
        default="Initial Commit",
        help="Initial commit to initialize the git repo with",
    )

    args = parser.parse_args()

    if not args.capitalized_name:
        args.capitalized_name = args.name.capitalize()
    return args


def get_git_user_info():
    try:
        author = (
            subprocess.check_output(["git", "config", "user.name"])
            .decode("utf-8")
            .strip()
        )
        email = (
            subprocess.check_output(["git", "config", "user.email"])
            .decode("utf-8")
            .strip()
        )
    except subprocess.CalledProcessError:
        sys.stderr.write(
            "Error: failed to get git user info. Pleaseinitialize git first:\n\n"
            'git config --global user.name "Your Name"\n'
            'git config --global user.email "your.email@example.com"\n'
        )
        exit(2)
    return author, email


def clean_repo():
    try:
        with open(os.devnull, "w") as devnull:
            subprocess.check_call(["just", "clean"], stderr=devnull, stdout=devnull)
    except subprocess.CalledProcessError:
        sys.stderr.write("Error: failed to clean repository.\n")
        exit(3)


def find_repo_root():
    try:
        repo_root = subprocess.check_output(["git", "rev-parse", "--show-toplevel"])
    except subprocess.CalledProcessError:
        sys.stderr.write("Error: failed to find repository root.\n")
        exit(4)
    return Path(repo_root.decode().strip()).resolve()


def make_replacements(repo_root, args, author, email):
    gitignore_patterns = _get_gitignore_patterns(repo_root)
    for file_path in repo_root.rglob("*"):
        if not file_path.is_file():
            continue
        if _is_ignored(file_path, gitignore_patterns, repo_root):
            continue
        if _is_binary(file_path):
            continue
        if file_path.name == "init":
            continue
        if any(".egg-info" in p for p in file_path.parts):
            continue
        if ".git" in file_path.parts:
            continue
        if ".venv" in file_path.parts:
            continue

        initial_content = file_path.read_text()
        content = (
            initial_content.replace("dotemplate", args.name)
            .replace("DoTemplate", args.capitalized_name)
            .replace("0.0.0", args.version)
            .replace("doplaydo", args.github_organization)
        )

        if file_path.name == "pyproject.toml":
            content = re.sub(
                r"^description[ ]*=.*",
                f'description = "{args.description}"',
                content,
                flags=re.MULTILINE,
            )
            content = re.sub(
                f"^authors[ ]*=.*",
                f'authors = [{{name = "{author}", email = "{email}"}}]',
                content,
                flags=re.MULTILINE,
            )

        if file_path.name == "mkdocs.yml":
            content = re.sub(
                r"^site_description[ ]*:.*",
                f"site_description: {args.description}",
                content,
                flags=re.MULTILINE,
            )
            content = re.sub(
                r"^site_author[ ]*:.*",
                f"site_author: {author}",
                content,
                flags=re.MULTILINE,
            )

        if file_path.name == "README.md":
            content = f"# {args.capitalized_name}\n\n{args.description}"

        if file_path.name == "CHANGELOG.md":
            content = ""

        if content != initial_content:
            print(f"Replacing {file_path}")
            file_path.write_text(content)


def _is_binary(file_path: Path) -> bool:
    """Returns True if the file appears to be binary."""
    try:
        with open(file_path, "tr") as check_file:
            check_file.readline()
            return False
    except UnicodeDecodeError:
        return True


def _get_gitignore_patterns(repo_root: Path) -> list[Pattern]:
    """Get compiled regex patterns from .gitignore file"""
    patterns = []
    gitignore_path = repo_root / ".gitignore"
    if gitignore_path.exists():
        with open(gitignore_path) as f:
            for line in f:
                line = line.strip()
                if line and not line.startswith("#"):
                    # Convert glob pattern to regex pattern
                    regex = fnmatch.translate(line)
                    patterns.append(re.compile(regex))
    return patterns


def _is_ignored(path: Path, patterns: list[Pattern], repo_root: Path) -> bool:
    """Check if path matches any gitignore pattern"""
    rel_path = str(path.relative_to(repo_root))
    return any(pattern.match(rel_path) for pattern in patterns)


def delete_init(repo_root: Path):
    init_path = repo_root / "init"
    if init_path.exists():
        init_path.unlink()


def initialize_git_repo(repo_root: Path, args):
    git_path = repo_root / ".git"
    if git_path.exists():
        shutil.rmtree(git_path)
    subprocess.check_call(["git", "init"], cwd=repo_root)
    subprocess.check_call(
        [
            "git",
            "remote",
            "add",
            "origin",
            f"git@github.com:{args.github_organization}/{args.name}.git",
        ],
        cwd=repo_root,
    )


def install_pre_commit(repo_root: Path):
    subprocess.check_call(["just", "dev"], cwd=repo_root)


def make_initial_commit(repo_root: Path, args):
    subprocess.check_call(["git", "add", "."], cwd=repo_root)
    subprocess.check_call(
        ["git", "commit", "-m", args.initial_commit, "--no-verify"], cwd=repo_root
    )

def move_source(repo_root: Path, args):
    src_path = repo_root / "src" / "dotemplate"
    dst_path = repo_root / "src" / args.name
    shutil.move(src_path, dst_path)

def remove_egg_info(repo_root: Path):
    egg_info_paths = (repo_root / "src").glob("*.egg-info")
    for path in egg_info_paths:
        shutil.rmtree(path)

def main():
    args = parse_args()
    print(args)
    author, email = get_git_user_info()
    print(author, email)
    repo_root = find_repo_root()
    print(repo_root)
    clean_repo()
    make_replacements(repo_root, args, author, email)
    move_source(repo_root, args)
    remove_egg_info(repo_root)
    initialize_git_repo(repo_root, args)
    install_pre_commit(repo_root)
    delete_init(repo_root)
    make_initial_commit(repo_root, args)


if __name__ == "__main__":
    main()
