<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>3D Geometry - Three.js Viewer</title>
    <style>
      body {{
          margin: 0;
          padding: 0;
          background-color: {background_color};
          font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
          overflow: hidden;
      }}
      #container {{
          width: {width};
          height: {height};
          position: relative;
      }}
      #info {{
          position: absolute;
          top: 20px;
          left: 20px;
          background: rgba(255,255,255,0.95);
          padding: 15px;
          border-radius: 8px;
          z-index: 100;
          font-size: 14px;
          box-shadow: 0 4px 12px rgba(0,0,0,0.15);
          max-width: 300px;
      }}
      #controls {{
          position: absolute;
          top: 20px;
          right: 20px;
          background: rgba(255,255,255,0.95);
          padding: 15px;
          border-radius: 8px;
          z-index: 100;
          box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      }}
      button {{
          margin: 3px;
          padding: 8px 12px;
          background: #007bff;
          color: white;
          border: none;
          border-radius: 5px;
          cursor: pointer;
          font-size: 13px;
          transition: background-color 0.2s;
      }}
      button:hover {{
          background: #0056b3;
      }}
      button:active {{
          background: #004085;
      }}
      #legend {{
          position: absolute;
          bottom: 20px;
          left: 20px;
          background: rgba(255,255,255,0.95);
          padding: 15px;
          border-radius: 8px;
          z-index: 100;
          max-height: 250px;
          overflow-y: auto;
          box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      }}
      .legend-item {{
          display: flex;
          align-items: center;
          margin: 4px 0;
          font-size: 13px;
      }}
      .legend-color {{
          width: 20px;
          height: 15px;
          margin-right: 10px;
          border: 1px solid #ddd;
          border-radius: 2px;
      }}
      #stats {{
          position: absolute;
          bottom: 20px;
          right: 20px;
          background: rgba(255,255,255,0.95);
          padding: 10px;
          border-radius: 8px;
          z-index: 100;
          font-size: 12px;
          box-shadow: 0 4px 12px rgba(0,0,0,0.15);
          display: {stats_display};
      }}
      h3 {{
          margin: 0 0 8px 0;
          color: #333;
      }}
      h4 {{
          margin: 0 0 8px 0;
          color: #555;
      }}
      p {{
          margin: 4px 0;
          color: #666;
      }}
    </style>
  </head>
  <body>
    <div id="container">
      <div id="info">
        <h3>ðŸ”¬ 3D Geometry Visualization</h3>
        <p><strong>Mouse:</strong> Rotate view</p>
        <p><strong>Wheel:</strong> Zoom in/out (enhanced sensitivity)</p>
        <p><strong>Right-click:</strong> Pan camera</p>
        <p><strong>Double-click:</strong> Reset view</p>
      </div>

      <div id="controls">
        <button onclick="toggleWireframe()">ðŸ”² Toggle Wireframe</button>
        <br />
        <button onclick="resetCamera()">ðŸŽ¯ Reset View</button>
        <br />
        <button onclick="toggleSimBox()">ðŸ“¦ Toggle Sim Box</button>
      </div>

      <div id="legend">
        <h4>ðŸ“Š Layers</h4>
        <div id="legend-content"></div>
      </div>

      <div id="stats">
        <div id="fps">FPS: --</div>
        <div id="vertices">Vertices: --</div>
        <div id="faces">Faces: --</div>
      </div>
    </div>

    <!-- Import maps for Three.js modules -->
    <script
      async
      src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"
    ></script>

    <script type="importmap">
      {{
          "imports": {{
              "three": "https://unpkg.com/three@0.154.0/build/three.module.js",
              "three/addons/": "https://unpkg.com/three@0.154.0/examples/jsm/"
          }}
      }}
    </script>

    <script type="module">
      // Import Three.js modules
      import * as THREE from 'three';
      import {{ OrbitControls }} from 'three/addons/controls/OrbitControls.js';
      import Stats from 'https://unpkg.com/three@0.154.0/examples/jsm/libs/stats.module.js';

      // Geometry data from Python
      const geometryData = {geometry_data};

      // Three.js setup
      let scene, camera, renderer, controls, stats;
      let geometryObjects = [];
      let simulationBox = null;
      let showWireframe = {show_wireframe};
      const SHOW_STATS = {show_stats};

      // Make functions globally available for buttons
      window.toggleWireframe = toggleWireframe;
      window.resetCamera = resetCamera;
      window.toggleSimBox = toggleSimBox;

      function init() {{
          // Scene
          scene = new THREE.Scene();
          scene.background = new THREE.Color(0xf0f0f0);

          // Camera
          camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
          camera.position.set(15, 15, 25);

          // Renderer
          renderer = new THREE.WebGLRenderer({{
              antialias: true,
              alpha: true
          }});
          renderer.setSize(window.innerWidth, window.innerHeight);
          renderer.shadowMap.enabled = true;
          renderer.shadowMap.type = THREE.PCFSoftShadowMap;
          renderer.setPixelRatio(window.devicePixelRatio);
          document.getElementById('container').appendChild(renderer.domElement);

          // Controls with enhanced zoom
          controls = new OrbitControls(camera, renderer.domElement);
          controls.enableDamping = true;
          controls.dampingFactor = 0.05;
          controls.zoomSpeed = 3.0;  // Enhanced zoom sensitivity for touchpad
          controls.panSpeed = 1.5;
          controls.rotateSpeed = 1.0;

          // Stats (only if enabled)
          if (SHOW_STATS) {{
              stats = new Stats();
              stats.dom.style.position = 'absolute';
              stats.dom.style.top = '0px';
              stats.dom.style.right = '0px';
              document.body.appendChild(stats.dom);
          }}

          // Lighting setup
          const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
          scene.add(ambientLight);

          const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
          directionalLight.position.set(30, 30, 30);
          directionalLight.castShadow = true;
          directionalLight.shadow.mapSize.width = 2048;
          directionalLight.shadow.mapSize.height = 2048;
          scene.add(directionalLight);

          // Load geometry
          loadGeometry();

          // Create legend
          createLegend();

          // Update stats
          updateStats();

          // Handle window resize
          window.addEventListener('resize', onWindowResize, false);

          // Start render loop
          animate();

          console.log('âœ… Three.js viewer initialized successfully');
      }}

      function loadGeometry() {{
          let totalVertices = 0, totalFaces = 0;

          console.log('Loading geometry data:', geometryData);

          if (!geometryData || !geometryData.layers) {{
              console.error('No geometry data available');
              return;
          }}

          geometryData.layers.forEach(layer => {{
              console.log(`Loading layer: ${{layer.name}}, meshes: ${{layer.meshes.length}}`);
              const color = new THREE.Color(`rgb(${{layer.color[0]}},${{layer.color[1]}},${{layer.color[2]}})`);

              layer.meshes.forEach(meshData => {{
                  console.log(`  Mesh vertices: ${{meshData.vertices.length}}, faces: ${{meshData.faces.length}}`);

                  // Create geometry
                  const geometry = new THREE.BufferGeometry();

                  // Set vertices
                  const vertices = new Float32Array(meshData.vertices);
                  geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));

                  // Set faces
                  const indices = new Uint16Array(meshData.faces);
                  geometry.setIndex(new THREE.BufferAttribute(indices, 1));

                  // Compute normals and bounding sphere
                  geometry.computeVertexNormals();
                  geometry.computeBoundingSphere();

                  totalVertices += vertices.length / 3;
                  totalFaces += indices.length / 3;

                  // Create material with enhanced settings
                  const material = new THREE.MeshLambertMaterial({{
                      color: color,
                      transparent: layer.opacity < 1.0,
                      opacity: layer.opacity,
                      side: THREE.DoubleSide,
                      flatShading: false
                  }});

                  // Create mesh
                  const mesh = new THREE.Mesh(geometry, material);
                  mesh.userData = {{
                      layerName: layer.name,
                      meshId: meshData.id,
                      originalColor: color.getHex()
                  }};
                  mesh.castShadow = true;
                  mesh.receiveShadow = true;

                  scene.add(mesh);
                  geometryObjects.push(mesh);

                  // Debug: Check if mesh was created properly
                  const bbox = new THREE.Box3().setFromObject(mesh);
                  console.log(`  Added mesh for layer ${{layer.name}}:`, {{
                      vertices: geometry.attributes.position.count,
                      faces: geometry.index ? geometry.index.count / 3 : 0,
                      boundingBox: bbox,
                      visible: mesh.visible
                  }});

                  // Add wireframe if requested
                  if (showWireframe) {{
                      addWireframe(mesh);
                  }}
              }});
          }});

          // Add simulation box
          if (geometryData.simulation_box) {{
              createSimulationBox();
          }}

          // Center camera on geometry
          centerCameraOnGeometry();

          console.log(`ðŸ“Š Loaded ${{geometryData.layers.length}} layers, ${{totalVertices}} vertices, ${{totalFaces}} faces`);
      }}

      function addWireframe(mesh) {{
          const wireframe = new THREE.WireframeGeometry(mesh.geometry);
          const wireframeMaterial = new THREE.LineBasicMaterial({{
              color: 0x000000,
              transparent: true,
              opacity: 0.3
          }});
          const wireframeMesh = new THREE.LineSegments(wireframe, wireframeMaterial);
          mesh.add(wireframeMesh);
      }}

      function createSimulationBox() {{
          const boxData = geometryData.simulation_box;
          const vertices = new Float32Array(boxData.vertices);
          const geometry = new THREE.BufferGeometry();
          geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));

          const indices = new Uint16Array(boxData.lines);
          geometry.setIndex(new THREE.BufferAttribute(indices, 1));

          const material = new THREE.LineDashedMaterial({{
              color: 0x000000,
              linewidth: 2,
              dashSize: 0.1,
              gapSize: 0.05,
              transparent: true,
              opacity: 0.8
          }});

          simulationBox = new THREE.LineSegments(geometry, material);
          simulationBox.computeLineDistances(); // Required for dashed lines
          scene.add(simulationBox);
      }}

      function createLegend() {{
          const legendContent = document.getElementById('legend-content');
          geometryData.layers.forEach(layer => {{
              const item = document.createElement('div');
              item.className = 'legend-item';

              const colorBox = document.createElement('div');
              colorBox.className = 'legend-color';
              colorBox.style.backgroundColor = `rgb(${{layer.color[0]}},${{layer.color[1]}},${{layer.color[2]}})`;
              colorBox.style.opacity = layer.opacity;

              const label = document.createElement('span');
              label.textContent = `${{layer.name}} (Î±=${{layer.opacity.toFixed(2)}})`;

              item.appendChild(colorBox);
              item.appendChild(label);
              legendContent.appendChild(item);
          }});
      }}

      function toggleWireframe() {{
          showWireframe = !showWireframe;
          geometryObjects.forEach(mesh => {{
              const wireframe = mesh.children.find(child => child.type === 'LineSegments');
              if (wireframe) {{
                  wireframe.visible = showWireframe;
              }} else if (showWireframe) {{
                  addWireframe(mesh);
              }}
          }});
          console.log(`ðŸ”² Wireframe: ${{showWireframe ? 'ON' : 'OFF'}}`);
      }}

      function resetCamera() {{
          centerCameraOnGeometry();
          console.log('ðŸŽ¯ Camera reset');
      }}

      function toggleSimBox() {{
          if (simulationBox) {{
              simulationBox.visible = !simulationBox.visible;
              console.log(`ðŸ“¦ Simulation box: ${{simulationBox.visible ? 'ON' : 'OFF'}}`);
          }}
      }}

      function centerCameraOnGeometry() {{
          if (geometryObjects.length === 0) {{
              console.log('No geometry objects to center on');
              camera.position.set(15, 15, 25);
              controls.target.set(0, 0, 0);
              return;
          }}

          const box = new THREE.Box3();
          geometryObjects.forEach(mesh => {{
              box.expandByObject(mesh);
          }});

          const center = box.getCenter(new THREE.Vector3());
          const size = box.getSize(new THREE.Vector3());

          console.log('Geometry bounds:', {{
              center: center,
              size: size,
              min: box.min,
              max: box.max
          }});

          const maxDim = Math.max(size.x, size.y, size.z);

          // Handle very small geometries (micrometers scale)
          const distance = maxDim > 0 ? maxDim * 2.5 : 50;

          camera.position.set(
              center.x + distance * 0.5,
              center.y + distance * 0.5,
              center.z + distance * 1.2
          );

          controls.target.copy(center);
          controls.update();

          // Adjust near/far planes for small geometries
          if (maxDim < 1) {{
              camera.near = 0.001;
              camera.far = 1000;
              camera.updateProjectionMatrix();
          }}

          console.log('Camera positioned at:', camera.position);
          console.log('Camera looking at:', controls.target);
      }}

      function updateStats() {{
          let totalVertices = 0, totalFaces = 0;
          geometryObjects.forEach(mesh => {{
              const geometry = mesh.geometry;
              totalVertices += geometry.attributes.position.count;
              totalFaces += geometry.index ? geometry.index.count / 3 : geometry.attributes.position.count / 3;
          }});

          document.getElementById('vertices').textContent = `Vertices: ${{totalVertices.toLocaleString()}}`;
          document.getElementById('faces').textContent = `Faces: ${{Math.floor(totalFaces).toLocaleString()}}`;
      }}

      function animate() {{
          requestAnimationFrame(animate);
          controls.update();
          if (stats) stats.update();
          renderer.render(scene, camera);
      }}

      function onWindowResize() {{
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(window.innerWidth, window.innerHeight);
      }}

      // Initialize when page loads
      init();
    </script>
  </body>
</html>
